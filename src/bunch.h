/*=========================================================================
 * 
 *  Program:   TEUFEL - THz Emission from Undulators and Free-Electron Lasers
 * 
 *  Copyright (c) 2017 U. Lehnert
 * 
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 * 
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 * 
 *  You should have received a copy of the GNU General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 * 
 * =========================================================================*/

#pragma once

#include "fields.h"
#include "fieldtrace.h"
#include "particle.h"
#include "vector.h"
#include <vector>

using namespace std;

/*!
 *    \class Distribution
 *    \brief Generate arrays of particle coordinates.
 * 
 *    @author Ulf Lehnert
 *    @date 17.5.2017
 *    
 *    This class provides means to create and handle certain distributions
 *    of particles in phase space. It is meant for the creation of 6D
 *    coordinate distributions which can be used by the bunch class
 *    to initialize particles for tracking.
 *
 *    The distribution is meant to define the particle coordinates
 *    with respect to a reference particle (or set of reference coordinates).
 *    Therefore the mean of the distribution is kept zero.
 *    This facilitates an easy addition of linear correlations.
 *    All displacements of the mean have to be added when generating
 *    a particle bunch from the distribution.
 */
class Distribution
{

public:
    
    /*! By default the distribution is initalized with particles
     *  uniformly distributed over the range [-1.0, 1.0) in all coordinates.
     *  The number of dimensions of the phase space and the number of particles
     *  to be created must be given.
     */
    Distribution(int dim, int nop);
    
    //! Destructor only used to free the memory
    ~Distribution();
    
    /*! Join in another distribution.
     *  This only works if both have the same number of dimensions.
     */
    void join(const Distribution *other);
    
    //! report number of dimensions
    int getDIM();
    
    //! report number of points
    int getNOP();
    
    /*! scale one of the dimensions by a given factor
     */
    void scale( int dim, double factor);
    
    /*! generate a gaussian distribution for one of the dimensions
     *  @todo: This should generate a strictly sequential Gaussian.
     *  The present code shoud be renamed generateNormalDist()
     */
    void generateGaussian( int dim, double sigma);
    
    /*! Add a correlation between two axis.
     *  The value of the independent coordinate multiplied with a factor
     *  is added to the dependent axis coordinate value.
     *
     *  The method is safeguarded against illegal corrdinate indexes.
     */
    void addCorrelation(int independent, int dependent, double factor);
    
    /*! Get one coordinate of one particle with given index.
     *  Out of range indices will not lead to errors, just return zero
     */
    double getCoordinate(int index, int dim);
    
    /*! Set one coordinate of one particle with given index.
     *  Out of range indices will not lead to errors.
     */
    void setCoordinate(int index, int dim, double value);
    
    /*! Fill the coordinate data into one externally provided buffer.
     *  If the sizes don't match throw an exception. This would be
     *  a programming error and should not get caught.
     */
    void bufferData(double *buffer, int bufsize);
    
    /*! Fill the coordinate data from one externally provided buffer.
     *  If the sizes don't match throw an exception. This would be
     *  a programming error and should not get caught.
     */
    void fromBuffer(double *buffer, int bufsize);

    /*! Create a subset of a given distribution. It yields number 
     *  particle coordinates starting at the given index.
     *  The subset is a newly constructed object. Any possibly requested
     *  points outside the dimensions of the orginal distribution
     *  are returned as random numbers as generated by the contructor
     *  but always a valid object of correct size is created.
     */
    Distribution* subDist(int index, int number);
    
private:
    
    //! the number of dimensions
    int DIM;
    
    //! the number of particles
    int NOP;
    
    //! the array of coordinates
    double* A;
    
};

/*!
    \class Bunch
    \brief Ensemble of particles
 
    @author Ulf Lehnert, Vipul Joshi
    @date 10.5.2017
    
    This is a container holding a number of particles. Tracking particles
    and computation of radiated fields are provided for all particles together.
    
    Creating a beam does not define inital coordinates of the particles.
    This is done when initalizing the tracking algorithm (e.g. InitVay() ).
 */
class Bunch
{

public:

    /*! default constructor: creates an empty bunch.
    */	
    Bunch();
    
    /*! create a bunch of given number of particles each having
     *  given charge and mass. Charge and mass are given in units of elementary
     *  charge and electron mass. So for a bunch of electrons the respective
     *  parameters are negative (charge) and positive (mass) number of
     *  electrons in the bunch.
     * 
     *  The particles have no initial coordinates
     */
    Bunch(int N, double charge, double mass);
    
    /*! create a bunch of particles with given coordinate distribution
     * each having given charge and mass.
     * 
     * The given distribution contains 3 position coordinates [m],
     * 3 momentum coordinates [] and the start time [s].
     * If the given distribution has less than 7 dimensions the missing
     * coordinates are initalized as 0 which can be used to start all
     * particles at zero time.
     * 
     * The given distribution contains the offsets from the given
     * reference position, momentum and time.
     */
    Bunch(Distribution *dist, double reftime, Vector refpos, Vector refmom, double charge, double mass);
    
    /*! create a bunch of particles read from an SDDS file (ELEGANT watch point)
     * 
     * The file name is given as parameter. If the file cannot be read successfully,
     * an empty bunch is created.
     * The bunch is propagating in the direction of the given vector.
     */
    Bunch(const char *filename, Vector dir);

    /*!
     * copy constructor:
     * Create a copy of an existing bunch, thereby, creating copies of all particles
     * of the original bunch. The original bunch is not altered.
     */
    Bunch(Bunch* origin);

    /*!
     * Destructor:
     * Deleting the bunch also deletes all contained particles
     */
    ~Bunch();

    /*!
     * Add a particle to the bunch.
     * The bunch then "owns" the particle and will delete it when destructed.
     */
    void Add(ChargedParticle *part);

    /*! Remove all trajectory information from particles
     * belonging to this bunch
     */
    void clearTrajectories();
    
    /*! For all particles belonging to this bunch pre-allocate a number of trajectory points.
     *  Note - this must be one more than the number of tracking steps
     */
    void preAllocate(int nTraj);

    //! Report the number of particles in the bunch.
    int getNOP();	

    //! Report the total charge of the particles contained in the bunch.
    double getTotalCharge();

    /*!
     * Get a pointer to a particle from its index within the bunch.
     * Returns a NULL pointer if the index is out of range.
     */
    ChargedParticle* getParticle(int i);
    
    /*!
     * The particle with the given index is deleted and
     * replaced by the given particle.
     * No action is performed if the index does not point to an existing particle.
     */
    void replaceParticle(int i, ChargedParticle* part);

    /*! @brief Setup for tracking the whole bunch using the Vay algorithm.
     * 
     * The inital coordinates of all particles must have been set before
     * 
     * See ChargedParticle::InitVay for details
     * 
     * @todo Tracking particles which do not start all at the same time
     * is not yet supported.
     * 
     * @param tstep the length of the time step.
     * @param field the field through which the particle will be tracked
     */
    void InitVay(double tstep,
		 GeneralField *field);

    /*! @brief Perform one tracking step using the Vay algorithm.
     * 
     * See ChargedParticle::StepVay for details
     * 
     * @param field the field through which the bunch is tracked
     */
    void StepVay(GeneralField *field);

    /*! @brief Buffer particle coordinates.
     * 
     * Particle coordinates (time,position,momentum,acceleration)
     * of all particles belonging to the bunch are stored into one buffer.
     * There is no memory check for the buffer size performed.
     * 
     * @param[in] buffer memory pointer of the buffer
     * 
     * @return the advanced buffer pointer
     */
    double *bufferStep(double *buffer);

    /*! @brief Set particle coordinates from buffer.
     * 
     * Particle coordinates (time,position,momentum,acceleration)
     * of all particles belonging to the bunch are read from one buffer.
     * There is no memory check for the buffer size performed.
     * For consecutively reading of many bunches the advanced buffer
     * pointer is returned after reading, then pointing to the
     * first particle of the next bunch (if existing)
     * 
     * @param[in] buffer memory pointer of the buffer
     * 
     * @return the advanced buffer pointer
     */
    double *setStepFromBuffer(double *buffer);

    /*! @brief Average time of all particles
     *  The averiging gives equal weight to all particles
     */
    double avgTime();
    
    /*! @brief Average position of all particles
     *  The averiging gives equal weight to all particles
     */
    Vector avgPosition();
    
    /*! @brief RMS size of particle distribution
     *  The averiging gives equal weight to all particles
     */
    Vector rmsPosition();
    
    /*! @brief Average momentum of all particles
     *  The averiging gives equal weight to all particles
     */
    Vector avgMomentum();

    /*! @brief write coordinates of all particles to a buffer
     *  @param buffer address of the buffer
     *  @param size maximum number of particles the buffer can hold
     *      The data writing stops when the buffer limit is reached
     *      even if not all particles have been written.
     *  @return pointer to the next empty memory place in the buffer.
     */
    double* bufferCoordinates(double *buffer, int size);
    
    /*! Dump all particle information into an SDDS file.
     *  The written quantities include:
     *  - time t
     *  - position x,y,z
     *  - momentum px,py,pz,p (beta*gamma)
     *  - angles xp,yp (px/pz, py/pz)
     *  - gamma
     * 
     * returns values for error checks:
     *	 
     *	0  -  successfully Written the file\n
     *	1  -  error in SDDS_InitializeOutput \n
     *	2  -  error in SDDS_DefineSimpleParameter \n
     *	3  -  error in SDDS_DefineColumn \n
     *	4  -  error in SDDS_WriteLayout \n
     *	5  -  error in SDDS_StartPage \n
     *	6  -  error in SDDS_SetParameters \n
     *	7  -  error in SDDS_SetRowValues \n
     *	8  -  error in SDDS_WritePage \n
     *	9  -  error in SDDS_Terminate \n
     * 
     */
    int WriteWatchPointSDDS(const char *filename);

    /*! @brief Get the field generated by a bunch of particles.
     *
     *  Compute the electromagnetic field radiated by the particles of a bunch
     *  as seen at the observation point at the given time.
     *  This method sums up the field generated by the individual particles.
     *  
     *  @param[in] obs_pos the position of the observer
     *  @param[in] obs_time the time of observation
     *
     *  @return the observed electromagnetic field
     *
     *  @throws RANGEexception
     *  An exception is thrown if any particle is not properly initialized.
     *  <br>
     */
    ElMagField RetardedField(double obs_time, Vector obs_pos);

    /*! Compute the electromagnetic field radiated by the bunch
     * seen at the observation point. The field is given in time domain
     * as defined in the FieldTrace object.
     * 
     * This method sums up the field generated by the individual particles.
     * All field contributions are just added to the trace
     * The caller may choose to start with a zero field
     * or to use this to sum up the fields of multiple bunches.
     * 
     * \param[in] ObservationPoint The position [m] of the observer.
     * \param[out] trace Electromagnetic field integrals at the observation point.
     */
    void integrateFieldTrace(
        Vector ObservationPoint,
        FieldTrace *trace);

private:

    //! Number of Particles in the bunch
    int NOP;

    //! time step for tracking - this will remain constant after being set at the start of tracking
    double dt;

    //! we store references to all particles
    vector<ChargedParticle*> P;

};
