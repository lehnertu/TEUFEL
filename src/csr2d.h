/*=========================================================================
 * 
 *  Program:   TEUFEL - THz Emission from Undulators and Free-Electron Lasers
 * 
 *  Copyright (c) 2017 U. Lehnert
 * 
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 * 
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 * 
 *  You should have received a copy of the GNU General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 * 
 * =========================================================================*/

#pragma once

#include "pugixml.hpp"
#include "vector.h"
#include "fields.h"
#include "beam.h"
#include "parser.h"
#include <vector>

/*!
 * \class CSR_2D
 * \brief An electromagnetic field interacting with the beam
 * @author Ulf Lehnert
 * @date 08.01.2025
 * 
 * This is an electromagnetic field described on a 2D grid
 * that is generated by a moving particle beam.
 * The grid propagates with the speed of light in a pre-defined direction
 * that is supposed to be aligned with the motion of the beam.
 * The field is assumed to be constant in the out-of-plane direction.
 * 
 * This field needs to be updated after every tracking step of the source beam
 * but is assumed to remain constant for the next tracking step
 * moving along with the beam.
 * While the number of grid cells is defined at creation of the object
 * the spacial extension of the grid is matched to the current beam size when updated.
 */
class CSR_2D : public InteractionField
{

public:

    /*! The default contructor just calls the default constructor of the base class
     *  and initalizes all variables with sane values. This will not yet produce any fields.
     */
    CSR_2D();

    /*! This constructor takes the information from an XML node
     *  describing all field properties. It will throw exceptions
     *  if necessary information is missing or cannot be interpreted.
     * 
     *  A reference to the input parser must be provided as it is
     *  necessary to run the input through the calculator.
     */
    CSR_2D(
        const pugi::xml_node node,
        InputParser *parser
        );

    /*! All derived classes from GeneralField must provide a destructor */
    virtual ~CSR_2D();

    /*! Do all necessary initializations before update() can be called.
     *  The given beam is defined as the field source.
     */
    virtual void init(Beam *beam);

    /*! Compute the interaction field for the current state of the beam
     *  given by the tracking_time. If the last stored trajectory point
     *  deviates by more than a fraction (presently 0.5) of a time_step
     *  an Exception is thrown.
     *
     *  After the call the fields can be used for tracking within on time_step.
     *  This method must be called in a leap-frog sequence interleaved with
     *  the tracking steps of the beam.
     *
     *  Every step_Output number of steps (including the first call)
     *  the computed grid is stored for later writing to a log file.
     */
    virtual void update(double tracking_time, double tracking_time_step);
    
    /*!
     * The electromagnetic field at a given time and point in space.
     * The time must be within a time step from the current time of the interaction field.
     * 
     * The requested position is projected into the grid plane.
     * The field is reported  with a constant value for out-off-plane positions.
     * If the requested position is projected outside the grid
     * an exception is thrown.
     * 
     * The coordinates [m] and the time [s] refer to the laboratory (rest) frame.
     * The field is returned as a tuple of electric field [V/m] and
     * magnetic field [T] vectors.
     */
    virtual ElMagField Field(double t, Vector X);

    /*! Write stored field data to file if requested (do nothing otherwise).
     *  This will be called after the tracking is finished.
     */
    virtual void write_output();

private:

    //! This is the field source as defined by init().
    Beam *source;
    
    //! number of the field grid cells in direction of motion
    int  N_long;
    
    //! number of the field grid cells transverse to the direction of motion
    int  N_trans;
    
    /*! The grid vector in propagation direction.
     *  This should be colinear with the average direction of motion of the beam
     *  but this is in the responsibility of the user  and not checked.
     */
    Vector e_long;

    /*! The grid vector in transverse direction.
     *  This vector is forced to be perpendicular to the propagation direction.
     *  It should lay in the bending plane of the trajectory
     *  but this is in the responsibility of the user  and not checked.
     */
    Vector e_trans;

    //! the interaction field array
    std::vector<ElMagField> interaction_field;

    //! nunmber of stored field maps
    int N_stored;
    
    //! storage of fields over the computed time-steps
    std::vector<std::vector<ElMagField>> field_storage;
    
    //! whether to create a field output file
    bool createOutput;
    
    //! how often to store a field output
    int step_Output;

    //! the output file name
    std::string FileName;

};

